package entities2;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;

/**
 *
 * @author Nina
 */

/*
Add a Tester-class, similar to day-1, add and execute this line, to verify that we can create the matching classes:
Persistence.generateSchema("NAME_OF YOUR_PU", null);
Important: The following exercises are just as much a recap on your second-semester knowledge related to relational mappings. DON’t skip the steps, where you are requested to compare Entity Classes to the generated tables. This is to a large degree what we will discuss during the examination when we are focusing on JPA.

1) One to One – Unidirectional
Provide the Customer with an Address field:
private Address address;  
NetBeans hint: Add the cursor on the field and press ALT + ENTER → Select Create unidirectional one to one relationship
Make sure you understand everything that changed in the Customer and (if any) in the Address class.
- There aren't any changes in the Address class, the only change in Customer is the @OneToOne the private Address address.

Regenerate the schema and investigate the generated tables. Observe the location of the foreign key
Important: Before you continue, make sure you understand (100% exam relevant) how an OO-language implements OneToOne relations and how a relational database does the same.
-	In the Customer table there is an added field “ADDRESS_ID” which has Null in the fields.

2) One to One – Bidirectional
Remove the @OneToOne annotation and create a bidirectional one to one relationship (with NetBeans use the same hint as above, and select the relevant option).
Make sure you understand what is meant by bidirectional before you continue (how would you show bidirectional using UML,
	Customer 1 -------- 1 Address
and how is it implemented in your two entity classes)
	It has the @OneToOne annotation 
A bidirectional relationship will obviously require a reference in the Address class, pointing back to Customer. Provide a name when requested by the wizard (customer) and select the default for the owning side.
Go to the Address class. Investigate and understand the generated code.
- The generated code in the Address class is
        "@OneToOne(mappedBy = "address")
        private Customer customer;"
    
Run the project and investigate the generated tables (the foreign key). Is there any difference compared to the previous exercise. If not explain why.
-	I don’t see any difference in the generated tables from before. 

3) OneToMany (unidirectional)
Remove the generated code in both classes and use the wizard, one more time.  This time to generate a OneToMany relationship. You obviously can’t do that with your current Address field so change it into:
private List<Address> addresses = new ArrayList();
Now, a Customer can have several addresses. If you feel the opposite makes more sense; an address can have more Customers (i.e two customers are married, and live together), just do that instead, this is a “business decision”.
Now, use the wizard to generate a OneToMany Unidirectional relationship.
•	Observe the generated code.
•	Run the project and investigate the generated tables. Make sure to press Refresh so see all tables.
•	How many tables were generated? Explain the purpose of each of the tables.
o	 Another table was generated, named CUSTOMER_ADDRESS
•	If you (as us) don't like the number of generated tables generated by this strategy, you can use the @JoinColumn annotation to implement the relation using a foreign key. Do this, but before you test, delete ALL generated tables in the database
•	Create a "test" method and insert a number of Customers with Addresses into the tables, using JPA.
4) OneToMany (bidirectional)
Remove the generated code in both classes and comment out your test code.
Use the wizard to generate a OneToMany Bidirectional relationship. Make sure you understand all the suggestions given by the wizard before you accept.
•	Observe the generated code, especially where we find the mappedBy value. Explain.
•	Run the project and investigate the generated tables (the foreign key). 
•	Create a "test" method and insert a number of Customers with Addresses into the tables, using JPA. Which extra step is required for this strategy compared to OneToMany unidirectional?

Again, before you continue, make sure you can explain/answer the questions above, and generally explain the generated tables and how they map to the code.
5) Many To Many (bidirectional)
Finally, let's implement a ManyToMany relationship between Customer and Address, That is: a customer can have many addresses, and an address can "have" many Customers.
IMPORTANT: Before you do this, refresh your knowledge from 1-2 semester and answer the following questions.
•	How can we implement ManyToMany relationships in an OO-language like Java?
•	How can we implement ManyToMany relationships in a Relational Database?

a) Remove the generated code in both classes
Right-click the addresses list and select create bidirectional Many to Many Relationship (observe; both sides can be the owning side)
•	Observe the generated code and make sure you understand every line generated in BOTH classes.
•	Run the project and investigate the generated tables. Explain ALL generated tables.
•	Create a "test" method and insert a number of Customers and Addresses. Make sure to test both the scenario where a customer can have more than one address and an Address can belong to more than one customer.
b) Create a "façade" class CustomerFacade and add the following methods:
Customer getCustomer(int id); 
List<Customer> getCustomers(); //(Check out the hints below)
Customer addCustomer(Customer cust);
Customer deleteCustomer(int id);
Customer editCustomer(Customer cust);
If not already done, provide the Customer Class with the following methods:
•	List<Address> getAddresses();
•	Void addAddress(Address address);
Provide the Address class with the similar methods (for Customers)
Hints   
Open the JPQL readings for tomorrow. Don’t read it, just find the SELECT queries near the top. You should be able to modify one for this use case.
In order to persist both a Customer and his Addresses you can:
•	Use the cascade property on the @ManyToMany annotation, or:
•	Persist the customer, and persist the addresses in the Customers address list.

*/


@Entity
public class Customer2 implements Serializable {

    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String firstName;
    private String lastName;
    @OneToMany(mappedBy = "customer2")
    private List<Address2> addresses = new ArrayList();

    public Customer2() {
    }

    public Customer2(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (id != null ? id.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof Customer2)) {
            return false;
        }
        Customer2 other = (Customer2) object;
        if ((this.id == null && other.id != null) || (this.id != null && !this.id.equals(other.id))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "Customer2{" + "id=" + id + ", firstName=" + firstName + ", lastName=" + lastName + ", addresses=" + addresses + '}';
    }

    void addAddressToCustomer(Address2 address) {
        addresses.add(address);
    }
}
